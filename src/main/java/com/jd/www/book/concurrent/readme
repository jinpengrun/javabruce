并发编程的挑战
1 上下文切换，多线程存在上下文切换 ： 线程将当前状态到加载到寄存器中这段时间 称为 上下文切换
上下文切换需要耗费时间
如何减少上下文切换
1 无锁并发编程
    避免使用锁，id根据hash算法取模分段，不同线程处理不同段的数据
2 cas算法
    不加锁更新数据 java 的cas
3 使用最少线程
    多的线程await 大量线程处于等候状态
4 协程
    单线程了实现多任务调度，在单线程里实现多个任务间的切换

1 死锁
sudo -u admin /opt/ifeve/java/bin/jstack 31177 > /home/tengfei.fangtf/dump17
查看线程处于什么状态，grep java.lang.Thread.State dump17 | awk '{print $2$3$4}' | sort | uniq -c
BLOCKED 大量处于阻塞状态

解决死锁的常见方法
1 避免一个线程同时获取多个锁
2 避免一个线程在锁内同时占用多个额资源，尽量保证每个锁占用一个资源
3 尝试使用内部锁机制， lock.tryLock(timeout)
4 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则解锁失败

资源限制
1 程序执行受限于计算机硬件资源或软件资源
    例如：带宽2m 某资源下载1m ，启动是个线程下载 也不会变为10m ，所以并发编程考虑资源
    软件资源限制有数据库和socket连接
  解决资源限制问题
    多机器执行，软件资源限制 使用连接池将 数据库和socket 连接复用。
    比如，线程的数量远大于数据库连接数，则某些线程将会被阻塞
4 在资源限制情况下进行并发编程
    根据不同的限制调整程序并发度，下载文件依赖两个资源-带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数
    如果sql语句执行非常快，线程数量比数据库连接大很多，则某些线程会被阻塞等待数据库连接。

two
java代码编译后编程java 字节码，字节码被类加载器加载到jvm里，jvm执行字节码，最终需要转化为汇编指令，在cpu执行
java 中所使用的并发机制依赖于jvm的实现和cpu指令， 探讨并发机制的底层实现原理

1 volatile 线程可见性 ，不会引起线程上下文的切换和调度。
cpu 术语定义
内存屏障 处理器指令，实现对内存操作的顺序限制
缓冲行 缓存中可以分配的最小存储单位
原子操作 不可中断的一个或一系列操作
缓存行填充 当处理器识别从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当缓存
缓存命中  从缓存读取操作数，不是从内存读取
写命中 将操作数写回到一个内存缓存的区域时，首先会检查这个缓存的内存地址是否在缓存行中，如果存在，写回缓存不是
        写回内存 ，操作被称为 写命中
写缺失 一个有效的缓存行被写入到不存在的内存区域

volatile 如何保证可见性，看x86处理器下通过工具获取jit 编译器生成的汇编指令，查看对volatile 进行写时候，cpu 会做什么事情
instance = new Singleton();
转汇编
0x01a3de1d: movb $0x0,0x1104800(%esi);
0x01a3de24:lock addl $0*0,(%esp);
volatile 变量修饰的共享变量进行写操作，多出第二行汇编代码，lock前缀的指令在多核处理器下回引发两件事
1 将当前处理器缓存行的数据写回系统内存
2 这个写回操作会使在其他cpu里缓存了该内存地址的数据无效。

volatile的使用优化

synchronized

原子操作的实现原理
intel处理器 和java 如何实现原子操作
1 术语
缓存行  缓存的最小操作单位
比较和交换  两个值 新值和旧值  旧值 比较 没变化 再替换
cpu流水线
内存顺序冲突 出现内存顺序冲突，必须清空 cpu流水线



three
1 java模型基础
县城之间如何通信以及线程之间如何同步，通信指线程之间以何种机制交换信息。
通信机制有两种：共享内存 和  消息传递

java并发采用共享内存模型。

2 java内存模型的抽象结构
java中 实例域，静态域，数组元素 都存储在堆，堆内存在线程之间共享。
java线程之间的通信由java内存模型，jmm控制，jmm决定一个线程对共享变量写入何时对另一个线程可见。

3 从源代码到指令序列的重排序
4 并发编程模型的分类

3 重排序
重排序是指编译器和处理器为了优化程序性能对指令序列进行重新排序的一种手段
    数据依赖性  不会对数据依赖关系的两个操作进行冲排序
    as-if-serial 排序不影响最终结果
    程序顺序规则
    重排序对多线程的影响



5java中的锁
 lock接口
    synchronized  隐式获取和释放锁
    lock 可操作性，可中断，超时获取锁等多种 特性

 同步器实现分析
    内部依赖内部的同步队列（一个fifo双向队列）完成同步状态的管理，当前线程获取同步状态失败时，同步器将当前线程以及等待状态等信息
    构造成一个节点node 并加入同步队列，同时阻塞当前线程，当同步状态释放，把首节点线程唤醒，使其尝试获取同步状态

    节点的属性
    int waitStatus  cancelled=1  signal=-1  condition = -2 propagate = -3 initial = 0
    Node prev
    Node nextWaiter
    Thread thread

    同步器是 实现各种锁的 关键  用不同同步器实现不同锁

 独占锁 和 共享锁
    独占和共享 对比
    共享式访问资源时，其他共享式被允许，而独占式访问被阻塞，  独占式访问资源时候，同一时刻其他访问均被阻塞

 自定义同步组件 TwinsLock

   重入锁
     ReentrantLock 支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁。除此之外还支持获取锁时的公平和非公平的选择
     我们实现的第一个test的锁，考虑如下场景，当一个线程调用lock 时候，如果再次调用lock方法，那么它会被自己阻塞，因为我们
     并没有考虑占有锁线程再次获取锁的场景，而在tryAcquire时候返回了false，导致线程被阻塞了，简单说我们实现的并不是一个可以
     重入锁。而Synchronized关键字隐式支持重新进入，比如一个synchronized修饰的递归方法，方法执行时，可以连续多次获取该锁
     ，不像我们实现的下次获取锁时会阻塞自己

     ReentrantLock 支持重入锁 支持公平锁 和 非公平锁


   读写锁
     我们实现的锁和reentrantLock都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程进行访问，
     但是在写线程的时候所有的读线程和其他写线程均被阻塞，读写锁维护了一对锁一个读锁 一个 写锁，通过分离锁使得并发性相比一般排它锁
     有了很大提升

     比如我们有个共享缓存数据结构，大部分时间提供读服务，写占用很少时间，但是写完成后需要对后续读服务可见
     没有读写锁前 我们就使用synchronized 进行读写同步，以确保读到完全正确的数据
     有了读写锁 性能就提升了
     ReentrantReadWriteLock 特性  公平性选择，重新进入，锁降级（遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级为读锁）


    读写锁实现分析
    undo
   LockSupport
    undo
   Condition接口
    任意一个java对象，都拥有一组监视器方法（wait,notify,notifyall等方法）
    Condition接口提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，差别如下

    Condition 接口与示例
        condition对象依赖于lock对象
    Condition 的实现
    undo
















