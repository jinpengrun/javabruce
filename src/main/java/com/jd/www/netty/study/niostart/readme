使用bytebuffer步骤
缓冲区本质：可以写入数据，从中读取数据的内存。内存被包装成nio buffer对象，提供一组方法
          用来方便的访问该块内存

          基本用法：写入数据到buffer
                   调用flip（）方法 将buffer从写模式切换到读模式
                   从buffer中读取数据
                   调用clear（）方法或者compact（）方法 clear清空全部，compact方法清空只会清除已经读过的数据，任何未读的数据都被移动到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面


                   方法： flip 写到读得切换  hasremaining() 是否有未读取信息 ，clear 清空 腾出空间供写入
                         compact 未读数据拷贝到buffer起始处，将position 设置到最后一个未读元素的后面 limit 设置成capacity ，可以写入数据 ，但是不能覆盖未读数据
                         put  get  写入和 读取
                         rewind 将position 设置为0 ， 你可以重新读取buffer 中所有数据 limit保持不变
                         mark  和 reset
                          mark标记buffer 中一个特定的position ， 之后可以用buffer.reset 进行恢复
                         使用equals 和 compareto 方法来比较两个buffer
                            相同类型， 剩余byte char 个数相等， 所有剩余byte， char等相同

                   buffer capacity容量 固定大小，往里面写  capacity个byte long char 一旦写满需要将其清空
                          position 位置  和  limit 含义取决于buffer 处在读模式 还是 写模式。
                                 表示当前位置  初始位置为0 ，插入一个后，position 会移动到下一个可插入数据的buffer单元 position最大为capacity - 1
                                 如果buffer 从 写模式 切换到读 ， position  会重置到0 ，当buffer的position处读取数据时，position向前移动到下一个可读的位置
                          limit  在写模式下bufferlimit表示你最多能往buffer 写多少数据 ， 写模式下，limit等于buffer 的capacity
                                 读模式下，limit表示你最多能读到多少数据，当切换buffer到读模式时，limit被设置成 写下 的position 值




java nio 中 的 scatter 和 gather
        分散和 聚集
        读多个buffer
        ByteBuffer header = ByteBuffer.allocate(128);
        ByteBuffer body   = ByteBuffer.allocate(1024);

        ByteBuffer[] bufferArray = { header, body };

        channel.read(bufferArray);


        写入到不同buffer
        ByteBuffer header = ByteBuffer.allocate(128);
        ByteBuffer body   = ByteBuffer.allocate(1024);

        //write data into buffers

        ByteBuffer[] bufferArray = { header, body };

        channel.write(bufferArray);


通道之间数据传输
    transferFrom  方法可以将数据从源通道传输到FileChannel中
    transferTo 方法将数据从FileChannel 传输到其他channel中

选择器 Selector
    java nio 可以检测一个到多个nio通道，一个线程可以管理多个channel，从而管理多个网络连接
    示例：一个selector 管理3个channel 的示例
    如果你对多个事件感兴趣，可以用位或将常量连接起来
    int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;


    select 阻塞到至少有一个通道在你注册的时间上就绪了
    select(long timeout) 最长会阻塞的毫秒数
    selectNow 不会阻塞，不管什么通道立即返回（直接返回0）

    selector.selectedKeys();就绪的key

    wakeup() 方法 某线程调用select 方法阻塞，即使没有通道就绪，调用selector.wakeup 方法即可
        若当前线程没有阻塞到select 上 ，下次调用select方法会立即返回

    close() 方法，用完selector调用其close方法关闭该selector 使所有selectionkey无效
        通道本身不会关闭
    完整实例
    Selector selector = Selector.open();
    channel.configureBlocking(false);
    SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
    while(true) {
      int readyChannels = selector.select();
      if(readyChannels == 0) continue;
      Set selectedKeys = selector.selectedKeys();
      Iterator keyIterator = selectedKeys.iterator();
      while(keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if(key.isAcceptable()) {
            // a connection was accepted by a ServerSocketChannel.
        } else if (key.isConnectable()) {
            // a connection was established with a remote server.
        } else if (key.isReadable()) {
            // a channel is ready for reading
        } else if (key.isWritable()) {
            // a channel is ready for writing
        }
        keyIterator.remove();
      }
    }


    Socket通道
     两种方式
     打开一个SocketChannel并连接到互联网上的某台服务器。
     一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。
     //连接到某台 机器
     SocketChannel socketChannel = SocketChannel.open();
     socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));
     用完之后 关闭
        socketChannel.close();
     读取  分配buffer
     ByteBuffer buf = ByteBuffer.allocate(48);
     int bytesRead = socketChannel.read(buf);

     写入socketchannel
     String newData = "New String to write to file..." + System.currentTimeMillis();

     ByteBuffer buf = ByteBuffer.allocate(48);
     buf.clear();
     buf.put(newData.getBytes());

     buf.flip();将此buffer转换为可读

     while(buf.hasRemaining()) {
         channel无法保证有多少可以写入到 channel 所以是一个 循环
         channel.write(buf);
     }

     socketchannel的连接
     socketChannel.configureBlocking(false);
     socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));
     //如果没有建立连接  不断的 循环
     while(! socketChannel.finishConnect() ){
         //wait, or do something else...
     }


     非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector


     serversocket通道
     打开通道
     ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

     serverSocketChannel.socket().bind(new InetSocketAddress(9999));

     while(true){
         SocketChannel socketChannel =
                 serverSocketChannel.accept();

         //do something with socketChannel...
     }

     关闭socket
     serverSocketChannel.close();
     循环监听 一个channel  阻塞模式
     while(true){
         SocketChannel socketChannel =
                 serverSocketChannel.accept();

         //do something with socketChannel...
     }

     非阻塞模式
     ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

     serverSocketChannel.socket().bind(new InetSocketAddress(9999));
     serverSocketChannel.configureBlocking(false);

     while(true){
         SocketChannel socketChannel =
                 serverSocketChannel.accept();

         if(socketChannel != null){
             //do something with socketChannel...
         }
     }


     datagramChannel
     UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。
     DatagramChannel channel = DatagramChannel.open();
     channel.socket().bind(new InetSocketAddress(9999));
     接收数据  buffer 如果容不下 buffer数据 多的数据将会被丢弃
     ByteBuffer buf = ByteBuffer.allocate(48);
     buf.clear();
     channel.receive(buf);

     发送
     String newData = "New String to write to file..." + System.currentTimeMillis();

     ByteBuffer buf = ByteBuffer.allocate(48);
     buf.clear();
     buf.put(newData.getBytes());
     buf.flip();

     int bytesSent = channel.send(buf, new InetSocketAddress("jenkov.com", 80));


     连接特定的 网络特定地址 无保障  只是 固定到一个连接
     channel.connect(new InetSocketAddress("jenkov.com", 80));
     int bytesRead = channel.read(buf);
     int bytesWritten = channel.write(but);


     PIPE JAVA NIO管道是两个线程之间单向的数据连接。

        例子
        Pipe pipe = Pipe.open();
        写数据 访问
        Pipe.SinkChannel sinkChannel = pipe.sink();
        String newData = "New String to write to file..." + System.currentTimeMillis();
        ByteBuffer buf = ByteBuffer.allocate(48);
        buf.clear();
        buf.put(newData.getBytes());

        buf.flip();

        while(buf.hasRemaining()) {
            sinkChannel.write(buf);
        }

        读数据
        Pipe.SourceChannel sourceChannel = pipe.source();
        从pipe 读取数据
        ByteBuffer buf = ByteBuffer.allocate(48);

        int bytesRead = inChannel.read(buf);